{% extends "base.html" %}
{% import 'macros/ui.html' as ui %}
{% block title %}Knowledge Base · Cornerstone{% endblock %}

{% block navigation %}
  {{ ui.navigation('knowledge') }}
{% endblock %}

{% block content %}
  <div class="knowledge-layout">
    <aside class="surface-card p-6 sm:p-8 space-y-8">
      <section class="space-y-3">
        <h1 class="text-2xl font-semibold text-slate-900">Projects</h1>
        <p class="text-sm text-slate-600">Manage knowledge bases and switch the active project.</p>
        <ul class="project-list">
          {% for project in projects %}
            <li class="{{ 'bg-blue-50 border-blue-200' if project.id == selected_project else '' }}">
              <a href="/knowledge?project_id={{ project.id }}" class="project-link {{ 'font-semibold text-blue-700' if project.id == selected_project else '' }}">{{ project.name }}</a>
              <span class="text-xs text-slate-500">{{ project.created_at.split('T')[0] }}</span>
            </li>
          {% endfor %}
        </ul>
      </section>

      <section class="space-y-4">
        <h2 class="text-lg font-semibold text-slate-900">Create Project</h2>
        <form method="post" action="/knowledge/projects" class="grid gap-3">
          <input type="text" name="name" placeholder="Project name" required class="form-input" />
          <textarea name="description" placeholder="Description (optional)" class="form-textarea min-h-[120px]"></textarea>
          <button type="submit" class="btn-primary">Create</button>
        </form>
      </section>

      <section class="space-y-4">
        <div class="space-y-2">
          <h2 class="text-lg font-semibold text-slate-900">Agent Persona</h2>
          <p class="text-sm text-slate-600">Assign a reusable persona from the catalog, then optionally layer project-specific overrides.</p>
          <a href="/personas" class="text-sm font-semibold text-primary hover:text-blue-700">Open persona catalog →</a>
        </div>

        <form class="persona-form grid gap-4" method="post" action="/knowledge/persona">
          <input type="hidden" name="project_id" value="{{ selected_project }}" />
          <div class="space-y-2">
            <label for="persona_id" class="text-sm font-semibold text-slate-700">Catalog persona</label>
            <select id="persona_id" name="persona_id" class="form-select">
              <option value="" {% if not project_persona_id %}selected{% endif %}>Default system persona</option>
              {% for catalog in personas %}
                <option value="{{ catalog.id }}" {% if project_persona_id == catalog.id %}selected{% endif %}>{{ catalog.name }}</option>
              {% endfor %}
            </select>
            <small class="text-xs text-slate-500">Selecting a persona applies its base instructions to this project.</small>
          </div>

          <fieldset class="grid gap-3">
            <legend class="text-sm font-semibold text-slate-700">Project overrides (optional)</legend>
            <div class="grid gap-3 sm:grid-cols-2">
              <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
                Display name
                <input id="persona_name" type="text" name="persona_name" value="{{ (persona_overrides.name if persona_overrides else '') or '' }}" placeholder="e.g. Atlas Assistant" class="form-input" />
              </label>
              <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
                Tone descriptor
                <input id="persona_tone" type="text" name="persona_tone" value="{{ (persona_overrides.tone if persona_overrides else '') or '' }}" placeholder="e.g. calm and encouraging" class="form-input" />
              </label>
            </div>
            <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
              System prompt additions
              <textarea id="persona_system_prompt" name="persona_system_prompt" rows="4" placeholder="Custom instructions for this project" class="form-textarea">{{ (persona_overrides.system_prompt if persona_overrides else '') or '' }}</textarea>
              <small class="text-xs text-slate-500">Overrides merge with the base persona. Leave blank to inherit.</small>
            </label>
            <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
              Avatar URL
              <input id="persona_avatar_url" type="url" name="persona_avatar_url" value="{{ (persona_overrides.avatar_url if persona_overrides else '') or '' }}" placeholder="Link to an image (optional)" class="form-input" />
            </label>
            <div class="grid gap-3 sm:grid-cols-2">
              <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
                Glossary top K
                <input id="persona_glossary" type="number" min="0" name="glossary_top_k" value="{{ (persona_overrides.glossary_top_k if persona_overrides else '') or '' }}" placeholder="default" class="form-input" />
              </label>
              <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
                Retrieval top K
                <input id="persona_retrieval" type="number" min="1" name="retrieval_top_k" value="{{ (persona_overrides.retrieval_top_k if persona_overrides else '') or '' }}" placeholder="default" class="form-input" />
              </label>
            </div>
            <div class="grid gap-3 sm:grid-cols-2">
              <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
                Temperature
                <input id="persona_temperature" type="number" min="0" step="0.1" name="chat_temperature" value="{{ (persona_overrides.chat_temperature if persona_overrides else '') or '' }}" placeholder="default" class="form-input" />
              </label>
              <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
                Max tokens
                <input id="persona_maxtokens" type="number" min="0" name="chat_max_tokens" value="{{ (persona_overrides.chat_max_tokens if persona_overrides else '') or '' }}" placeholder="auto" class="form-input" />
              </label>
            </div>
          </fieldset>
          <button type="submit" class="btn-primary">Save persona overrides</button>
        </form>

        {% if persona_snapshot %}
          <div class="persona-preview">
            <strong>{{ persona_snapshot.base_persona.name if persona_snapshot.base_persona else 'Persona preview' }}</strong>
            {% if persona_snapshot.base_persona and persona_snapshot.base_persona.tags %}
              <span>Tags: {{ persona_snapshot.base_persona.tags | join(', ') }}</span>
            {% endif %}
            {% if persona_snapshot.base_persona and persona_snapshot.base_persona.description %}
              <p>{{ persona_snapshot.base_persona.description }}</p>
            {% endif %}
          </div>
        {% endif %}
      </section>
    </aside>

    <section
      class="space-y-6"
      data-project-id="{{ selected_project }}"
      data-default-hint-batch="{{ settings.query_hint_batch_size }}"
      data-cleanup-job="{{ cleanup_job_id }}"
    >
      <div class="surface-card p-6 sm:p-8 space-y-6">
        <header class="space-y-2">
          <h1 class="text-2xl font-semibold text-slate-900">Documents</h1>
          <p class="text-sm text-slate-600">Upload documents to enrich <strong>{{ project_name }}</strong>.</p>
        </header>
        <div class="upload-panel">
          <div id="drop-zone" class="drop-zone" tabindex="0">
            <strong>Drop files here</strong>
            <p>Supported formats: TXT, MD, PDF, DOCX, HTML</p>
            <p class="text-sm text-slate-500">Files upload asynchronously so you can keep working.</p>
          </div>
          <div class="upload-actions">
            <button type="button" id="select-files" class="btn-primary">Select files</button>
          </div>
          <div class="space-y-3">
            <label for="local-path" class="text-sm font-semibold text-slate-700">Import local directory</label>
            <div class="local-input-group">
              <div class="local-input-wrapper">
                <input id="local-path" placeholder="e.g. team-notes/2024-q2" autocomplete="off" spellcheck="false" list="local-directories" class="form-input" />
                <datalist id="local-directories"></datalist>
              </div>
              <button type="button" id="import-local" class="btn-ghost">Import</button>
            </div>
            <div id="local-directory-meta" class="text-xs text-slate-500"></div>
            <span class="text-xs text-slate-500">Directories are resolved relative to <code>data/local/</code>.</span>
          </div>
          <div class="space-y-3">
            <label for="url-input" class="text-sm font-semibold text-slate-700">Fetch from URL</label>
            <div class="url-input-group">
              <input id="url-input" type="url" placeholder="https://example.com/help.html" class="form-input" />
              <button type="button" id="submit-url" class="btn-ghost">Fetch &amp; Ingest</button>
            </div>
            <span class="text-xs text-slate-500">We download the page HTML and embed it like other documents.</span>
          </div>
          <input id="file-input" type="file" name="files" accept=".txt,.md,.markdown,.pdf,.docx,.html" multiple hidden />
          <ul id="upload-status" class="upload-status"></ul>
          <noscript>
            <form method="post" action="/knowledge/upload" enctype="multipart/form-data" class="mt-4 space-y-3">
              <input type="hidden" name="project_id" value="{{ selected_project }}" />
              <input type="file" name="file" accept=".txt,.md,.markdown,.pdf,.docx,.html" required class="form-input" />
              <button type="submit" class="btn-primary">Upload &amp; Ingest</button>
            </form>
          </noscript>
        </div>
        <form id="cleanup-form" method="post" action="/knowledge/cleanup" class="flex items-center gap-3">
          <input type="hidden" name="project_id" value="{{ selected_project }}" />
          <button id="cleanup-button" type="submit" class="btn-ghost bg-slate-900 text-white hover:bg-slate-800">Clear embedded data</button>
          <span class="text-xs text-slate-500">Removes all vectors and document records for this project.</span>
        </form>
        <div id="cleanup-status" class="cleanup-status" aria-live="polite"></div>
      </div>

      {% if documents %}
        <div class="knowledge-table-card space-y-5">
          {% if pagination %}
            <div class="table-toolbar">
              <span class="table-summary">Showing {{ pagination.start_index + 1 }}–{{ pagination.end_index }} of {{ pagination.total_documents }} documents</span>
              <div class="pager">
                {% if pagination.has_prev %}
                  <a class="pager-link" href="/knowledge?project_id={{ selected_project }}&amp;page={{ pagination.page - 1 }}">Previous</a>
                {% else %}
                  <span class="pager-link disabled">Previous</span>
                {% endif %}
                <span class="pager-page">Page {{ pagination.page }} of {{ pagination.total_pages }}</span>
                {% if pagination.has_next %}
                  <a class="pager-link" href="/knowledge?project_id={{ selected_project }}&amp;page={{ pagination.page + 1 }}">Next</a>
                {% else %}
                  <span class="pager-link disabled">Next</span>
                {% endif %}
              </div>
            </div>
          {% endif %}
          <div class="table-wrapper">
            <table class="min-w-full divide-y divide-slate-200 text-sm">
              <thead class="bg-slate-50">
                <tr>
                  <th scope="col" class="whitespace-nowrap px-4 py-3 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">Filename</th>
                  <th scope="col" class="px-4 py-3 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">Source</th>
                  <th scope="col" class="whitespace-nowrap px-4 py-3 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">Size</th>
                  <th scope="col" class="whitespace-nowrap px-4 py-3 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">Chunks</th>
                  <th scope="col" class="whitespace-nowrap px-4 py-3 text-left text-xs font-semibold uppercase tracking-wide text-slate-500">Last updated</th>
                </tr>
              </thead>
              <tbody class="divide-y divide-slate-200">
                {% for doc in documents %}
                  <tr>
                    <td class="px-4 py-3 font-medium text-slate-900">{{ doc.filename }}</td>
                    <td class="px-4 py-3 text-slate-600">{{ doc.source }}</td>
                    <td class="px-4 py-3 text-slate-600">{{ doc.filesize }}</td>
                    <td class="px-4 py-3 text-slate-600">{{ doc.chunk_count }}</td>
                    <td class="px-4 py-3 text-slate-600">{{ doc.updated_at }}</td>
                  </tr>
                {% endfor %}
              </tbody>
            </table>
          </div>
        </div>
      {% else %}
        <div class="knowledge-table-card text-sm text-slate-600">
          No documents ingested yet. Upload files or fetch from a URL to populate the knowledge base.
        </div>
      {% endif %}

      <div class="glossary-panel" id="glossary-panel">
        <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
          <div>
            <h2 class="text-lg font-semibold text-slate-900">Glossary</h2>
            <p class="text-sm text-slate-600">Define key terms and reference phrases to help the agent answer consistently.</p>
          </div>
          <button type="button" id="glossary-cancel" class="btn-ghost hidden">Cancel editing</button>
        </div>
        <form id="glossary-form" class="glossary-form-grid">
          <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
            Term
            <input id="glossary-term" type="text" placeholder="e.g. SLA" required class="form-input" />
          </label>
          <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
            Synonyms
            <input id="glossary-synonyms" type="text" placeholder="Comma-separated alternate names" class="form-input" />
          </label>
          <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
            Keywords
            <input id="glossary-keywords" type="text" placeholder="Comma-separated search keywords" class="form-input" />
          </label>
          <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700 md:col-span-2">
            Definition
            <textarea id="glossary-definition" rows="4" placeholder="Write a concise, user-facing explanation" required class="form-textarea"></textarea>
          </label>
          <div class="entry-actions md:col-span-2">
            <button type="submit" id="glossary-submit" class="btn-primary">Save entry</button>
            <span id="glossary-status" class="glossary-status"></span>
          </div>
        </form>
        <ul id="glossary-entries" class="glossary-list"></ul>
      </div>

      <div class="glossary-panel" id="query-hints-panel">
        <div class="flex flex-col gap-2">
          <div class="flex flex-col gap-2 sm:flex-row sm:items-center sm:justify-between">
            <div>
              <h2 class="text-lg font-semibold text-slate-900">Query Hint Bridges</h2>
              <p class="text-sm text-slate-600">Cross-language tokens appended to chat queries before retrieval.</p>
            </div>
            <div class="flex flex-wrap items-center gap-2">
              <button type="button" id="query-hints-generate" class="btn-primary">Generate</button>
              <button type="button" id="query-hints-refresh" class="btn-ghost">Refresh</button>
              <button type="button" id="query-hints-download" class="btn-ghost">Download JSON</button>
            </div>
          </div>
          <div class="flex flex-wrap items-end gap-4">
            <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
              Batch size
              <input id="query-hints-batch-size" type="number" min="1" max="20" value="" class="form-input max-w-[6rem]" />
            </label>
            <label class="flex flex-col gap-2 text-sm font-semibold text-slate-700">
              Auto refresh
              <select id="query-hints-schedule" class="form-select min-w-[10rem]">
                <option value="" selected>Manual only</option>
                <option value="daily">Nightly</option>
                <option value="weekly">Weekly</option>
              </select>
            </label>
          </div>
        </div>
        <div id="query-hints-status" class="query-hints-status"></div>
        <ul id="query-hints-list" class="glossary-list"></ul>
      </div>
    </section>
  </div>
{% endblock %}

{% block scripts %}
  <script>
    (function () {
      const dropZone = document.getElementById('drop-zone');
      const fileInput = document.getElementById('file-input');
      const selectBtn = document.getElementById('select-files');
      const statusList = document.getElementById('upload-status');
      const projectSelect = document.getElementById('project');
      const projectSection = document.querySelector('section[data-project-id]');
      const initialCleanupJob = {{ cleanup_job_json | safe }};
      const cleanupForm = document.getElementById('cleanup-form');
      const cleanupButton = document.getElementById('cleanup-button');
      const cleanupStatus = document.getElementById('cleanup-status');
      const urlInput = document.getElementById('url-input');
      const submitUrl = document.getElementById('submit-url');
      const localPathInput = document.getElementById('local-path');
      const localDataList = document.getElementById('local-directories');
      const directoryMeta = document.getElementById('local-directory-meta');
      const importLocalBtn = document.getElementById('import-local');
      const localDirectoryCache = new Map();
      const LOCAL_DIRECTORY_ROOT_KEY = '__root__';
      let localDirectoryRequestId = 0;
      let localDirectoryFetchTimer = null;
      let localDirectoryActiveQuery = '';
      if (!dropZone || !fileInput || !selectBtn || !statusList || !projectSection) {
        return;
      }

      let projectId = projectSection.dataset.projectId || '';
      let cleanupJobId = projectSection.dataset.cleanupJob || '';
      const cleanupButtonDefaultLabel = cleanupButton ? cleanupButton.textContent : 'Clear embedded data';
      let cleanupPollTimer = null;
      const urlParams = new URLSearchParams(window.location.search);
      const cleanupExistingNotice = urlParams.has('cleanup_existing');
      if (cleanupExistingNotice) {
        urlParams.delete('cleanup_existing');
        const newSearch = urlParams.toString();
        const newUrl = `${window.location.pathname}${newSearch ? `?${newSearch}` : ''}${window.location.hash}`;
        window.history.replaceState({}, document.title, newUrl);
      }
      const activeJobs = new Set();
      let pollTimer = null;
      const STATUS_LABELS = {
        completed: 'completed',
        failed: 'failed',
        pending: 'pending',
        processing: 'processing',
        queued: 'queued',
        throttled: 'throttled',
      };

      function renderJobs(jobs) {
        statusList.innerHTML = '';
        if (!jobs || !jobs.length) {
          return;
        }
        const fragment = document.createDocumentFragment();
        [...jobs].forEach((job) => {
          const item = document.createElement('li');
          item.dataset.jobId = job.id;
          item.className = job.status || '';
          const row = document.createElement('div');
          row.className = 'job-row';
          const name = document.createElement('span');
          name.textContent = job.filename || 'File';
          const status = document.createElement('span');
          status.className = 'status';
          status.textContent = STATUS_LABELS[job.status] || job.status;
          row.appendChild(name);
          row.appendChild(status);
          if (job.error) {
            const error = document.createElement('span');
            error.className = 'job-error';
            error.textContent = job.error;
            row.appendChild(error);
          }
          item.appendChild(row);

          const hasTotals = typeof job.total_files === 'number' && job.total_files > 0;
          if (hasTotals) {
            const progress = document.createElement('div');
            progress.className = 'job-progress';
            const bar = document.createElement('div');
            bar.className = 'job-progress-bar';
            const fraction = Math.min(1, Math.max(0, Number(job.processed_files || 0) / Number(job.total_files || 1)));
            bar.style.width = `${Math.round(fraction * 100)}%`;
            progress.appendChild(bar);
            item.appendChild(progress);

            const label = document.createElement('div');
            label.className = 'job-progress-label';
            label.textContent = `${job.processed_files || 0} / ${job.total_files} files`;
            item.appendChild(label);
          }

          if (job.status === 'throttled') {
            const throttle = document.createElement('div');
            throttle.className = 'job-throttled-note';
            const processed = Math.max(0, Math.min(job.total_files || 0, job.processed_files || 0));
            throttle.textContent = `Queue throttled (${processed} / ${job.total_files || 0} files queued)`;
            item.appendChild(throttle);
          }

          fragment.appendChild(item);
        });
        statusList.appendChild(fragment);
      }

      function clearCleanupStatus() {
        if (!cleanupStatus) {
          return;
        }
        cleanupStatus.classList.remove('active');
        cleanupStatus.innerHTML = '';
      }

      function renderCleanupJob(job, options = {}) {
        if (!cleanupStatus) {
          return;
        }
        if (!job) {
          clearCleanupStatus();
          return;
        }
        cleanupStatus.classList.add('active');
        cleanupStatus.innerHTML = '';

        const summary = document.createElement('div');
        summary.className = 'cleanup-summary';
        let summaryText = options.notice || '';
        if (!summaryText) {
          switch ((job.status || '').toLowerCase()) {
            case 'completed':
              summaryText = 'Embedded data cleanup completed.';
              break;
            case 'failed':
              summaryText = 'Embedded data cleanup failed.';
              break;
            case 'running':
              summaryText = 'Clearing embedded data…';
              break;
            case 'queued':
            case 'pending':
            default:
              summaryText = 'Cleanup queued…';
              break;
          }
        }
        summary.textContent = summaryText;
        cleanupStatus.appendChild(summary);

        if (Array.isArray(job.steps) && job.steps.length) {
          const list = document.createElement('ul');
          list.className = 'step-list';
          job.steps.forEach((step) => {
            const item = document.createElement('li');
            item.className = 'step-item';

            const column = document.createElement('div');
            column.className = 'step-column';

            const label = document.createElement('div');
            label.className = 'step-label';
            label.textContent = step.label || step.name || 'Step';
            column.appendChild(label);

            if (step.details) {
              const detail = document.createElement('div');
              detail.className = 'step-detail';
              detail.textContent = step.details;
              column.appendChild(detail);
            }
            if (step.error) {
              const error = document.createElement('div');
              error.className = 'step-error';
              error.textContent = step.error;
              column.appendChild(error);
            }

            const state = document.createElement('span');
            const stepStatus = (step.status || 'pending').toLowerCase();
            state.className = `step-state ${stepStatus}`;
            state.textContent = stepStatus;

            item.appendChild(column);
            item.appendChild(state);
            list.appendChild(item);
          });
          cleanupStatus.appendChild(list);
        }

        if (job.error) {
          const jobError = document.createElement('div');
          jobError.className = 'job-error';
          jobError.textContent = job.error;
          cleanupStatus.appendChild(jobError);
        }
      }

      function stopCleanupPolling() {
        if (cleanupPollTimer) {
          window.clearInterval(cleanupPollTimer);
          cleanupPollTimer = null;
        }
      }

      async function pollCleanupJob() {
        if (!cleanupJobId) {
          stopCleanupPolling();
          return;
        }
        try {
          const response = await fetch(`/knowledge/cleanup/jobs/${encodeURIComponent(cleanupJobId)}`);
          if (!response.ok) {
            throw new Error(`Status request failed (${response.status})`);
          }
          const data = await response.json();
          if (!data || !data.job) {
            throw new Error('Malformed cleanup status payload.');
          }
          renderCleanupJob(data.job);
          const state = (data.job.status || '').toLowerCase();
          if (state === 'completed') {
            stopCleanupPolling();
            return;
          }
          if (state === 'failed') {
            stopCleanupPolling();
          }
        } catch (error) {
          console.error('Cleanup status polling failed', error);
          stopCleanupPolling();
          if (cleanupStatus) {
            const message = document.createElement('div');
            message.className = 'job-error';
            message.textContent = 'Unable to refresh cleanup status.';
            cleanupStatus.appendChild(message);
          }
        }
      }

      function startCleanupPolling(immediate = false) {
        stopCleanupPolling();
        if (!cleanupJobId) {
          return;
        }
        cleanupPollTimer = window.setInterval(pollCleanupJob, 1800);
        if (immediate) {
          pollCleanupJob();
        }
      }

      function parseListInput(value) {
        if (!value) {
          return [];
        }
        const parts = Array.isArray(value) ? value : String(value).split(',');
        const seen = new Set();
        parts.forEach((part) => {
          const cleaned = String(part).trim();
          if (cleaned) {
            seen.add(cleaned);
          }
        });
        return Array.from(seen);
      }

      function setGlossaryStatus(message, tone = 'info') {
        const el = document.getElementById('glossary-status');
        if (!el) {
          return;
        }
        el.textContent = message || '';
        if (!message) {
          el.style.color = '';
          return;
        }
        if (tone === 'error') {
          el.style.color = '#b91c1c';
        } else if (tone === 'success') {
          el.style.color = '#047857';
        } else {
          el.style.color = '#6b7280';
        }
      }

      function setQueryHintsStatus(message, tone = 'info') {
        const el = document.getElementById('query-hints-status');
        if (!el) {
          return;
        }
        el.textContent = message || '';
        if (!message) {
          el.style.color = '';
          return;
        }
        if (tone === 'error') {
          el.style.color = '#b91c1c';
        } else if (tone === 'success') {
          el.style.color = '#047857';
        } else {
          el.style.color = '#6b7280';
        }
      }

      const glossaryTerm = document.getElementById('glossary-term');
      const glossarySynonyms = document.getElementById('glossary-synonyms');
      const glossaryKeywords = document.getElementById('glossary-keywords');
      const glossaryDefinition = document.getElementById('glossary-definition');
      const glossaryForm = document.getElementById('glossary-form');
      const glossaryCancel = document.getElementById('glossary-cancel');
      const glossaryList = document.getElementById('glossary-entries');
      const glossarySubmit = document.getElementById('glossary-submit');
      const queryHintsList = document.getElementById('query-hints-list');
      const queryHintsGenerate = document.getElementById('query-hints-generate');
      const queryHintsRefresh = document.getElementById('query-hints-refresh');
      const queryHintsDownload = document.getElementById('query-hints-download');
      const queryHintsBatchInput = document.getElementById('query-hints-batch-size');
      const queryHintsSchedule = document.getElementById('query-hints-schedule');

      let editingGlossaryId = null;
      let glossaryEntries = [];
      let queryHintsData = {};

      function resetGlossaryForm() {
        editingGlossaryId = null;
        if (glossaryTerm) glossaryTerm.value = '';
        if (glossaryDefinition) glossaryDefinition.value = '';
        if (glossarySynonyms) glossarySynonyms.value = '';
        if (glossaryKeywords) glossaryKeywords.value = '';
        if (glossaryCancel) glossaryCancel.classList.add('hidden');
        if (glossaryForm) {
          glossaryForm.dataset.mode = 'create';
        }
      }

      function populateGlossaryForm(entry) {
        editingGlossaryId = entry.id;
        if (glossaryTerm) glossaryTerm.value = entry.term || '';
        if (glossaryDefinition) glossaryDefinition.value = entry.definition || '';
        if (glossarySynonyms) glossarySynonyms.value = (entry.synonyms || []).join(', ');
        if (glossaryKeywords) glossaryKeywords.value = (entry.keywords || []).join(', ');
        if (glossaryCancel) glossaryCancel.classList.remove('hidden');
        if (glossaryForm) {
          glossaryForm.dataset.mode = 'edit';
        }
      }

      function renderGlossaryEntries(entries) {
        if (!glossaryList) {
          return;
        }
        glossaryList.innerHTML = '';
        if (!entries.length) {
          const empty = document.createElement('li');
          empty.className = 'text-sm text-slate-500';
          empty.textContent = 'No glossary entries yet.';
          glossaryList.appendChild(empty);
          return;
        }

        entries.forEach((entry) => {
          const item = document.createElement('li');
          item.className = 'glossary-entry';

          const header = document.createElement('div');
          header.className = 'flex flex-col gap-1 sm:flex-row sm:items-center sm:justify-between';
          const title = document.createElement('h3');
          title.className = 'text-sm font-semibold text-slate-800';
          title.textContent = entry.term || 'Entry';
          header.appendChild(title);
          if (entry.updated_at) {
            const timestamp = document.createElement('span');
            timestamp.className = 'text-xs text-slate-500';
            timestamp.textContent = `Updated ${entry.updated_at}`;
            header.appendChild(timestamp);
          }
          item.appendChild(header);

          if (entry.definition) {
            const definition = document.createElement('p');
            definition.className = 'mt-2 text-sm text-slate-600';
            definition.textContent = entry.definition;
            item.appendChild(definition);
          }

          if (entry.synonyms && entry.synonyms.length) {
            const synonyms = document.createElement('div');
            synonyms.className = 'text-xs text-slate-500';
            synonyms.textContent = `Synonyms: ${entry.synonyms.join(', ')}`;
            item.appendChild(synonyms);
          }

          if (entry.keywords && entry.keywords.length) {
            const keywords = document.createElement('div');
            keywords.className = 'text-xs text-slate-500';
            keywords.textContent = `Keywords: ${entry.keywords.join(', ')}`;
            item.appendChild(keywords);
          }

          const actions = document.createElement('div');
          actions.className = 'entry-actions';
          const editBtn = document.createElement('button');
          editBtn.type = 'button';
          editBtn.className = 'btn-ghost text-sm';
          editBtn.textContent = 'Edit';
          editBtn.addEventListener('click', () => populateGlossaryForm(entry));

          const deleteBtn = document.createElement('button');
          deleteBtn.type = 'button';
          deleteBtn.className = 'btn-ghost text-sm text-rose-600 hover:text-rose-700';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => removeGlossaryEntry(entry.id));

          actions.appendChild(editBtn);
          actions.appendChild(deleteBtn);
          item.appendChild(actions);

          glossaryList.appendChild(item);
        });
      }

      function renderQueryHints(data) {
        if (!queryHintsList) {
          return;
        }
        queryHintsList.innerHTML = '';
        const entries = Object.entries(data || {});
        if (!entries.length) {
          const empty = document.createElement('li');
          empty.className = 'text-sm text-slate-500';
          empty.textContent = 'No query hints generated yet.';
          queryHintsList.appendChild(empty);
          return;
        }

        entries.forEach(([key, value]) => {
          const item = document.createElement('li');
          item.className = 'glossary-entry';

          const title = document.createElement('h3');
          title.className = 'text-sm font-semibold text-slate-800';
          title.textContent = key;
          item.appendChild(title);

          const body = document.createElement('p');
          body.className = 'mt-2 text-sm text-slate-600 whitespace-pre-wrap';
          body.textContent = Array.isArray(value) ? value.join(', ') : String(value);
          item.appendChild(body);

          queryHintsList.appendChild(item);
        });
      }

      async function loadGlossaryEntries() {
        if (!glossaryList) {
          return;
        }
        if (!projectId) {
          glossaryEntries = [];
          renderGlossaryEntries(glossaryEntries);
          return;
        }
        try {
          const response = await fetch(`/knowledge/glossary?project_id=${encodeURIComponent(projectId)}`);
          if (!response.ok) {
            throw new Error(`Failed to fetch glossary (${response.status})`);
          }
          const data = await response.json();
          glossaryEntries = data.entries || [];
          renderGlossaryEntries(glossaryEntries);
          setGlossaryStatus('');
        } catch (error) {
          console.error(error);
          glossaryEntries = [];
          renderGlossaryEntries(glossaryEntries);
          setGlossaryStatus('Unable to load glossary entries.', 'error');
        }
      }

      async function loadQueryHints() {
        if (!queryHintsList) {
          return;
        }
        if (!projectId) {
          queryHintsData = {};
          renderQueryHints(queryHintsData);
          return;
        }
        try {
          const response = await fetch(`/knowledge/query-hints?project_id=${encodeURIComponent(projectId)}`);
          if (!response.ok) {
            throw new Error(`Failed to fetch query hints (${response.status})`);
          }
          const data = await response.json();
          queryHintsData = data.hints || {};
          renderQueryHints(queryHintsData);
          const meta = data.metadata || {};
          if (queryHintsBatchInput) {
            if (meta.batch_size) {
              queryHintsBatchInput.value = meta.batch_size;
            } else if (!queryHintsBatchInput.value) {
              queryHintsBatchInput.value = {{ settings.query_hint_batch_size }};
            }
          }
          if (queryHintsSchedule) {
            queryHintsSchedule.value = meta.schedule || '';
          }
          if (meta.last_generated) {
            const generatedDate = new Date(meta.last_generated);
            const display = Number.isNaN(generatedDate.getTime()) ? meta.last_generated : generatedDate.toLocaleString();
            setQueryHintsStatus(`Last generated ${display}`, 'info');
          } else {
            setQueryHintsStatus('');
          }
        } catch (error) {
          console.error('Failed to load query hints', error);
          queryHintsData = {};
          renderQueryHints(queryHintsData);
          setQueryHintsStatus('Unable to load query hints.', 'error');
        }
      }

      async function submitGlossaryEntry(event) {
        event.preventDefault();
        if (!projectId) {
          setGlossaryStatus('Select a project before adding glossary entries.', 'error');
          return;
        }
        const term = glossaryTerm ? glossaryTerm.value.trim() : '';
        const definition = glossaryDefinition ? glossaryDefinition.value.trim() : '';
        if (!term || !definition) {
          setGlossaryStatus('Term and definition are required.', 'error');
          return;
        }
        const payload = {
          project_id: projectId,
          term,
          definition,
          synonyms: parseListInput(glossarySynonyms ? glossarySynonyms.value : ''),
          keywords: parseListInput(glossaryKeywords ? glossaryKeywords.value : ''),
        };
        const isUpdate = Boolean(editingGlossaryId);
        const url = isUpdate ? `/knowledge/glossary/${editingGlossaryId}` : '/knowledge/glossary';
        const method = isUpdate ? 'PUT' : 'POST';
        try {
          if (glossarySubmit) {
            glossarySubmit.disabled = true;
          }
          const response = await fetch(url, {
            method,
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            const reason = detail.detail || `status ${response.status}`;
            throw new Error(`Failed to save entry (${reason})`);
          }
          await loadGlossaryEntries();
          setGlossaryStatus(isUpdate ? 'Glossary entry updated.' : 'Glossary entry added.', 'success');
          resetGlossaryForm();
        } catch (error) {
          console.error(error);
          setGlossaryStatus('Unable to save glossary entry.', 'error');
        } finally {
          if (glossarySubmit) {
            glossarySubmit.disabled = false;
          }
        }
      }

      async function removeGlossaryEntry(entryId) {
        if (!projectId) {
          return;
        }
        if (!window.confirm('Delete this glossary entry?')) {
          return;
        }
        try {
          const response = await fetch(`/knowledge/glossary/${encodeURIComponent(entryId)}?project_id=${encodeURIComponent(projectId)}`, {
            method: 'DELETE',
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            const reason = detail.detail || `status ${response.status}`;
            throw new Error(`Failed to delete entry (${reason})`);
          }
          if (editingGlossaryId === entryId) {
            resetGlossaryForm();
          }
          await loadGlossaryEntries();
          setGlossaryStatus('Glossary entry removed.', 'success');
        } catch (error) {
          console.error(error);
          setGlossaryStatus('Unable to delete glossary entry.', 'error');
        }
      }

      async function downloadQueryHints() {
        if (!projectId) {
          setQueryHintsStatus('Select a project to download hints.', 'error');
          return;
        }
        try {
          const response = await fetch(`/knowledge/query-hints?project_id=${encodeURIComponent(projectId)}`);
          if (!response.ok) {
            throw new Error(`Download failed (${response.status})`);
          }
          const data = await response.json();
          const payload = data.hints || {};
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const link = document.createElement('a');
          link.href = url;
          link.download = `query-hints-${projectId}.json`;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          URL.revokeObjectURL(url);
          setQueryHintsStatus('Query hints downloaded.', 'success');
        } catch (error) {
          console.error('Download failed', error);
          setQueryHintsStatus('Unable to download query hints.', 'error');
        }
      }

      async function generateQueryHints() {
        if (!projectId) {
          setQueryHintsStatus('Select a project before generating hints.', 'error');
          return;
        }
        if (queryHintsGenerate) {
          queryHintsGenerate.disabled = true;
        }
        setQueryHintsStatus('Generating query hints…');
        try {
          const response = await fetch('/knowledge/query-hints/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              project_id: projectId,
              batch_size: queryHintsBatchInput && queryHintsBatchInput.value ? Number(queryHintsBatchInput.value) : undefined,
              schedule: queryHintsSchedule ? queryHintsSchedule.value : '',
            }),
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            const reason = detail.detail || `status ${response.status}`;
            throw new Error(`Generation failed (${reason})`);
          }
          if (!response.body) {
            throw new Error('Streaming not supported in this browser');
          }
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = '';
          let latestBackend = 'unknown backend';
          let latestPrompts = '?';
          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }
            buffer += decoder.decode(value, { stream: true });
            let newlineIndex;
            while ((newlineIndex = buffer.indexOf('\n')) >= 0) {
              const line = buffer.slice(0, newlineIndex).trim();
              buffer = buffer.slice(newlineIndex + 1);
              if (!line) {
                continue;
              }
              let payload;
              try {
                payload = JSON.parse(line);
              } catch (error) {
                console.error('Failed to parse hint stream chunk', line);
                continue;
              }
              if (payload.event === 'progress') {
                setQueryHintsStatus(`Processing batch ${payload.batch}…`);
              } else if (payload.event === 'completed') {
                queryHintsData = payload.hints || {};
                renderQueryHints(queryHintsData);
                latestBackend = payload.backend || latestBackend;
                latestPrompts = typeof payload.prompts === 'number' ? payload.prompts : latestPrompts;
                const generatedDate = new Date();
                const display = generatedDate.toLocaleString();
                setQueryHintsStatus(`Query hints generated via ${latestBackend} (prompts ${latestPrompts}) at ${display}.`, 'success');
                if (queryHintsGenerate) {
                  queryHintsGenerate.title = `Last generated via ${latestBackend} (prompts ${latestPrompts})`;
                }
              }
            }
          }
          const remaining = buffer.trim();
          if (remaining) {
            try {
              const payload = JSON.parse(remaining);
              if (payload.event === 'completed') {
                queryHintsData = payload.hints || {};
                renderQueryHints(queryHintsData);
                const backend = payload.backend || 'unknown backend';
                const prompts = typeof payload.prompts === 'number' ? payload.prompts : '?';
                const generatedDate = new Date();
                const display = generatedDate.toLocaleString();
                setQueryHintsStatus(`Query hints generated via ${backend} (prompts ${prompts}) at ${display}.`, 'success');
                if (queryHintsGenerate) {
                  queryHintsGenerate.title = `Last generated via ${backend} (prompts ${prompts})`;
                }
              }
            } catch (error) {
              console.error('Failed to parse trailing hint chunk', remaining);
            }
          }
        } catch (error) {
          console.error('Hint generation failed', error);
          setQueryHintsStatus('Unable to generate query hints.', 'error');
        } finally {
          if (queryHintsGenerate) {
            queryHintsGenerate.disabled = false;
          }
        }
      }

      async function uploadFiles(fileList) {
        const files = Array.from(fileList || []);
        if (!files.length) {
          return;
        }
        const formData = new FormData();
        formData.append('project_id', projectId);
        files.forEach((file) => formData.append('files', file));
        renderJobs([]);
        try {
          const response = await fetch('/knowledge/uploads', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            renderJobs([
              {
                id: 'error',
                filename: 'Upload',
                status: 'failed',
                error: detail.detail || 'Upload failed.',
                updated_at: new Date().toISOString(),
              },
            ]);
            return;
          }
          const payload = await response.json();
          if (payload.jobs && payload.jobs.length) {
            payload.jobs.forEach((job) => activeJobs.add(job.id));
            renderJobs(payload.jobs);
            startPolling();
          }
        } catch (error) {
          renderJobs([
            {
              id: 'error',
              filename: 'Upload',
              status: 'failed',
              error: error.message,
              updated_at: new Date().toISOString(),
            },
          ]);
        }
      }

      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        dropZone.classList.add('dragover');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
      });

      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropZone.classList.remove('dragover');
        if (event.dataTransfer && event.dataTransfer.files) {
          uploadFiles(event.dataTransfer.files);
        }
      });

      dropZone.addEventListener('click', () => fileInput.click());

      dropZone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });

      selectBtn.addEventListener('click', () => fileInput.click());

      fileInput.addEventListener('change', (event) => {
        if (event.target.files) {
          uploadFiles(event.target.files);
          event.target.value = '';
        }
      });

      async function uploadUrl() {
        if (!urlInput) {
          return;
        }
        const value = urlInput.value.trim();
        if (!value) {
          return;
        }
        const formData = new FormData();
        formData.append('project_id', projectId);
        formData.append('url', value);
        renderJobs([]);
        try {
          const response = await fetch('/knowledge/upload-url', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            renderJobs([
              {
                id: 'url-error',
                filename: value,
                status: 'failed',
                error: detail.detail || 'URL upload failed.',
                updated_at: new Date().toISOString(),
              },
            ]);
            return;
          }
          const payload = await response.json();
          if (payload.job) {
            activeJobs.add(payload.job.id);
            renderJobs([payload.job]);
            startPolling();
            urlInput.value = '';
          }
        } catch (error) {
          renderJobs([
            {
              id: 'url-error',
              filename: value,
              status: 'failed',
              error: error.message,
              updated_at: new Date().toISOString(),
            },
          ]);
        }
      }

      if (submitUrl) {
        submitUrl.addEventListener('click', uploadUrl);
      }

      if (urlInput) {
        urlInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            uploadUrl();
          }
        });
      }

      async function importLocalDirectory() {
        if (!localPathInput) {
          return;
        }
        const value = localPathInput.value.trim();
        if (!value) {
          return;
        }
        const formData = new FormData();
        formData.append('project_id', projectId);
        formData.append('path', value);
        try {
          const response = await fetch('/knowledge/local-import', {
            method: 'POST',
            body: formData,
          });
          if (!response.ok) {
            const detail = await response.json().catch(() => ({}));
            renderJobs([
              {
                id: 'local-error',
                filename: value,
                status: 'failed',
                error: detail.detail || 'Local import failed.',
                updated_at: new Date().toISOString(),
              },
            ]);
            return;
          }
          const payload = await response.json();
          if (payload.job) {
            renderJobs([payload.job]);
            activeJobs.add(payload.job.id);
            startPolling();
          }
        } catch (error) {
          renderJobs([
            {
              id: 'local-error',
              filename: value,
              status: 'failed',
              error: error.message,
              updated_at: new Date().toISOString(),
            },
          ]);
        } finally {
          if (localPathInput) {
            scheduleLocalDirectoryRefresh(localPathInput.value);
            updateDirectoryMeta(localPathInput.value);
            focusLocalDirectoryInput();
          }
        }
      }

      if (importLocalBtn) {
        importLocalBtn.addEventListener('click', importLocalDirectory);
      }

      if (localPathInput) {
        localPathInput.addEventListener('keydown', (event) => {
          if (event.key === 'Enter') {
            event.preventDefault();
            importLocalDirectory();
          }
        });
      }

      async function pollStatuses() {
        if (!activeJobs.size) {
          stopPolling();
          return;
        }
        try {
          const response = await fetch(`/knowledge/uploads?project_id=${encodeURIComponent(projectId)}`);
          if (!response.ok) {
            throw new Error('Failed to poll job status');
          }
          const data = await response.json();
          renderJobs(data.jobs);
          const completed = (data.jobs || []).filter((job) => activeJobs.has(job.id) && (job.status === 'completed' || job.status === 'failed'));
          for (const job of completed) {
            activeJobs.delete(job.id);
          }
          if (!activeJobs.size) {
            stopPolling();
          }
        } catch (error) {
          console.error('Status polling failed', error);
          stopPolling();
        }
      }

      function startPolling() {
        stopPolling();
        pollTimer = window.setInterval(pollStatuses, 1800);
        pollStatuses().catch(() => {});
      }

      function stopPolling() {
        if (pollTimer) {
          window.clearInterval(pollTimer);
          pollTimer = null;
        }
      }

      if (cleanupForm) {
        cleanupForm.addEventListener('submit', async (event) => {
          event.preventDefault();
          if (!cleanupButton || cleanupButton.disabled) {
            return;
          }
          cleanupButton.disabled = true;
          cleanupButton.textContent = 'Clearing…';
          try {
            const formData = new FormData(cleanupForm);
            const response = await fetch('/knowledge/cleanup', {
              method: 'POST',
              body: formData,
            });
            if (!response.ok) {
              const detail = await response.json().catch(() => ({}));
              throw new Error(detail.detail || `status ${response.status}`);
            }
            const payload = await response.json();
            if (payload.job) {
              cleanupJobId = payload.job.id;
              renderCleanupJob(payload.job, { notice: 'Cleanup started. Tracking progress…' });
              startCleanupPolling(true);
            }
          } catch (error) {
            console.error('Cleanup request failed', error);
            renderCleanupJob(null);
            const summary = document.createElement('div');
            summary.className = 'cleanup-summary';
            summary.textContent = 'Unable to start cleanup.';
            cleanupStatus.appendChild(summary);
            const err = document.createElement('div');
            err.className = 'job-error';
            err.textContent = error instanceof Error ? error.message : String(error);
            cleanupStatus.appendChild(err);
          } finally {
            cleanupButton.disabled = false;
            cleanupButton.textContent = cleanupButtonDefaultLabel;
          }
        });
      }

      function normalizeLocalDirectoryPath(value) {
        if (!value) {
          return '';
        }
        const trimmed = String(value).trim();
        if (!trimmed) {
          return '';
        }
        const slashAdjusted = trimmed.replace(/\\/g, '/');
        return slashAdjusted.replace(/\/{2,}/g, '/').replace(/^\//, '');
      }

      async function loadLocalDirectories(path = '') {
        if (!localDataList) {
          return [];
        }
        const normalized = normalizeLocalDirectoryPath(path);
        const cacheKey = normalized || LOCAL_DIRECTORY_ROOT_KEY;
        const requestId = ++localDirectoryRequestId;
        try {
          let endpoint = '/knowledge/local-directories';
          if (normalized) {
            endpoint = `${endpoint}?path=${encodeURIComponent(normalized)}`;
          }
          const response = await fetch(endpoint);
          if (!response.ok) {
            return localDirectoryCache.get(cacheKey) || [];
          }
          const data = await response.json();
          const directories = data.directories || [];
          localDirectoryCache.set(cacheKey, directories);
          if (requestId === localDirectoryRequestId && localDirectoryActiveQuery === normalized) {
            renderLocalDirectoryOptions(directories);
          }
          return directories;
        } catch (error) {
          console.error('Failed to load local directories', error);
          return localDirectoryCache.get(cacheKey) || [];
        }
      }

      function renderLocalDirectoryOptions(entries) {
        if (!localDataList) {
          return;
        }
        localDataList.innerHTML = '';
        entries.forEach((dir) => {
          const option = document.createElement('option');
          option.value = dir.path;
          option.label = dir.path;
          option.dataset.fileCount = dir.file_count;
          option.dataset.totalBytes = dir.total_bytes;
          localDataList.appendChild(option);
        });
      }

      function scheduleLocalDirectoryRefresh(value) {
        if (localDirectoryFetchTimer) {
          window.clearTimeout(localDirectoryFetchTimer);
        }
        const normalized = normalizeLocalDirectoryPath(value);
        localDirectoryActiveQuery = normalized;
        let immediateEntries = null;
        if (normalized) {
          immediateEntries = localDirectoryCache.get(LOCAL_DIRECTORY_ROOT_KEY);
          if (immediateEntries) {
            immediateEntries = immediateEntries.filter((entry) => entry.path.startsWith(normalized));
          }
        } else {
          immediateEntries = localDirectoryCache.get(LOCAL_DIRECTORY_ROOT_KEY);
        }
        if (!immediateEntries) {
          immediateEntries = localDirectoryCache.get(LOCAL_DIRECTORY_ROOT_KEY);
        }
        let displayEntries = immediateEntries || [];
        if (normalized && displayEntries.length) {
          displayEntries = displayEntries.filter((entry) => entry.path.startsWith(normalized));
        }
        renderLocalDirectoryOptions(displayEntries);
        localDirectoryFetchTimer = window.setTimeout(() => {
          loadLocalDirectories(normalized).catch(() => {});
        }, 200);
      }

      function updateDirectoryMeta(value) {
        if (!directoryMeta) {
          return;
        }
        const option = Array.from(localDataList?.options || []).find((opt) => opt.value === value);
        if (!option) {
          directoryMeta.textContent = '';
          return;
        }
        const files = Number(option.dataset.fileCount || 0);
        const bytes = Number(option.dataset.totalBytes || 0);
        if (!files) {
          directoryMeta.textContent = 'No supported files detected';
          return;
        }
        directoryMeta.textContent = `${files} file${files === 1 ? '' : 's'} · ${formatBytes(bytes)}`;
      }

      function formatBytes(bytes) {
        if (!Number.isFinite(bytes) || bytes <= 0) {
          return '0 B';
        }
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let value = bytes;
        let unitIndex = 0;
        while (value >= 1024 && unitIndex < units.length - 1) {
          value /= 1024;
          unitIndex += 1;
        }
        const precision = value >= 10 || value < 0.1 ? 0 : 1;
        return `${value.toFixed(precision)} ${units[unitIndex]}`;
      }

      if (localPathInput) {
        const handleLocalDirectoryChange = (event) => {
          const nextValue = event.target.value;
          updateDirectoryMeta(nextValue);
          scheduleLocalDirectoryRefresh(nextValue);
        };
        localPathInput.addEventListener('input', handleLocalDirectoryChange);
        localPathInput.addEventListener('change', handleLocalDirectoryChange);
        localPathInput.addEventListener('focus', (event) => {
          scheduleLocalDirectoryRefresh(event.target.value);
        });
      }

      if (glossaryForm) {
        glossaryForm.addEventListener('submit', submitGlossaryEntry);
      }
      if (glossaryCancel) {
        glossaryCancel.addEventListener('click', resetGlossaryForm);
      }
      if (queryHintsGenerate) {
        queryHintsGenerate.addEventListener('click', generateQueryHints);
      }
      if (queryHintsRefresh) {
        queryHintsRefresh.addEventListener('click', loadQueryHints);
      }
      if (queryHintsDownload) {
        queryHintsDownload.addEventListener('click', downloadQueryHints);
      }
      if (projectSelect) {
        projectSelect.addEventListener('change', () => {
          projectId = projectSelect.value || '';
          if (projectSection) {
            projectSection.dataset.projectId = projectId;
          }
          resetGlossaryForm();
          loadGlossaryEntries();
          loadQueryHints();
        });
      }

      resetGlossaryForm();
      loadGlossaryEntries();
      loadQueryHints();
      loadLocalDirectories();
      focusLocalDirectoryInput();

      function focusLocalDirectoryInput(selectText = true) {
        if (!localPathInput) {
          return;
        }
        const runner = () => {
          if (!localPathInput) {
            return;
          }
          try {
            localPathInput.focus({ preventScroll: true });
          } catch (focusError) {
            localPathInput.focus();
          }
          if (selectText && localPathInput.value) {
            localPathInput.select();
          }
        };
        if (typeof window.requestAnimationFrame === 'function') {
          window.requestAnimationFrame(runner);
        } else {
          window.setTimeout(runner, 0);
        }
      }
    })();
  </script>
{% endblock %}
