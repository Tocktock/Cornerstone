<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Keyword Explorer</title>
    <style>
      body { font-family: sans-serif; margin: 0; background: #f3f4f6; color: #111827; }
      nav { background: #111827; padding: 1rem 2rem; display: flex; gap: 1.5rem; flex-wrap: wrap; }
      nav a { color: #d1d5db; text-decoration: none; }
      nav a strong { color: #fff; }
      main { max-width: 1100px; margin: 2.5rem auto; display: grid; gap: 1.5rem; grid-template-columns: minmax(0, 360px) minmax(0, 1fr); }
      section, aside { background: #fff; border-radius: 16px; padding: 1.75rem 2rem; box-shadow: 0 18px 38px rgba(15, 23, 42, 0.12); }
      h1 { margin-top: 0; }
      .form-grid { display: grid; gap: 0.85rem; }
      select { padding: 0.75rem 1rem; border-radius: 10px; border: 1px solid #d1d5db; font-size: 1rem; }
      button.primary { padding: 0.65rem 1.5rem; border-radius: 999px; border: none; background: #2563eb; color: #fff; font-size: 1rem; cursor: pointer; justify-self: start; box-shadow: 0 12px 28px rgba(37,99,235,0.2); transition: transform 0.15s ease, box-shadow 0.2s ease; }
      button.primary:disabled { background: #9ca3af; cursor: not-allowed; box-shadow: none; }
      button.primary:not(:disabled):hover { transform: translateY(-1px); box-shadow: 0 16px 32px rgba(37,99,235,0.26); }
      .keyword-list { display: flex; flex-wrap: wrap; gap: 0.6rem; margin-top: 1.25rem; }
      .keyword-pagination { display: none; align-items: center; gap: 0.75rem; margin-top: 1rem; }
      .keyword-pagination.active { display: flex; }
      .keyword-pagination button { padding: 0.4rem 0.9rem; border-radius: 999px; border: 1px solid #d1d5db; background: #fff; color: #1f2937; font-size: 0.85rem; cursor: pointer; transition: background 0.2s ease, color 0.2s ease, box-shadow 0.2s ease; }
      .keyword-pagination button:hover:not(:disabled) { background: #eff6ff; color: #1d4ed8; box-shadow: 0 6px 18px rgba(37,99,235,0.12); }
      .keyword-pagination button:disabled { cursor: not-allowed; opacity: 0.5; box-shadow: none; }
      .keyword-pagination span { font-size: 0.85rem; color: #4b5563; }
      .keyword-pill { display: inline-flex; align-items: center; gap: 0.45rem; padding: 0.55rem 0.95rem; border-radius: 999px; border: 1px solid #d1d5db; background: #f9fafb; cursor: pointer; font-size: 0.95rem; transition: all 0.2s ease; box-shadow: 0 4px 12px rgba(15, 23, 42, 0.08); }
      .keyword-pill.core { border-color: #1d4ed8; background: #dbeafe; font-weight: 600; }
      .keyword-pill.active { background: #2563eb; border-color: #1e3a8a; color: #fff; box-shadow: 0 10px 28px rgba(37,99,235,0.28); }
      .keyword-pill.generated { border-style: dashed; background: #fef3c7; }
      .keyword-pill:hover { border-color: #2563eb; color: #1d4ed8; }
      .keyword-pill.active:hover { color: #fff; }
      .keyword-count { font-size: 0.8rem; opacity: 0.75; }
      .status-line { color: #6b7280; font-size: 0.9rem; margin-top: 0.65rem; }
      .progress-track { display: none; position: relative; height: 4px; border-radius: 999px; background: #e5e7eb; overflow: hidden; margin-top: 0.5rem; max-width: 280px; }
      .progress-track.active { display: block; }
      .progress-indicator { position: relative; height: 100%; width: 100%; overflow: hidden; border-radius: inherit; }
      .progress-indicator::after { content: ""; position: absolute; inset: 0; width: 45%; background: linear-gradient(90deg, rgba(59,130,246,0.1), rgba(59,130,246,0.7), rgba(59,130,246,0.1)); animation: slide 1.2s ease-in-out infinite; border-radius: inherit; }
      @keyframes slide { 0% { transform: translateX(-60%); } 50% { transform: translateX(140%); } 100% { transform: translateX(-60%); } }
      .detail-header { display: flex; justify-content: space-between; align-items: center; gap: 1rem; }
      .detail-header h2 { margin: 0; font-size: 1.4rem; }
      .detail-actions { display: flex; align-items: center; gap: 0.75rem; }
      .save-button { padding: 0.5rem 1.2rem; border-radius: 999px; border: none; background: #2563eb; color: #fff; font-size: 0.95rem; cursor: pointer; box-shadow: 0 10px 24px rgba(37,99,235,0.18); }
      .save-button:disabled { background: #9ca3af; cursor: not-allowed; box-shadow: none; }
      .save-status { font-size: 0.85rem; color: #6b7280; }
      .detail-columns { display: grid; gap: 1.25rem; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); margin-top: 1.5rem; }
      .detail-card { border: 1px solid #e5e7eb; border-radius: 14px; padding: 1rem 1.25rem; background: #f9fafb; box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08); min-height: 180px; display: flex; flex-direction: column; }
      .detail-card h3 { margin: 0 0 0.85rem; font-size: 1.1rem; }
      .candidate-item { margin-bottom: 0.75rem; padding-bottom: 0.75rem; border-bottom: 1px solid #e5e7eb; }
      .candidate-item:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
      .candidate-meta { font-size: 0.85rem; color: #4b5563; margin-bottom: 0.35rem; }
      .candidate-snippet { white-space: pre-wrap; font-size: 0.95rem; margin: 0; line-height: 1.45; }
      .definition-item { margin-bottom: 0.65rem; padding: 0.6rem 0.7rem; border-radius: 10px; background: #fff; border: 1px solid #e5e7eb; box-shadow: inset 0 1px 2px rgba(15, 23, 42, 0.05); }
      .insight-list { display: grid; gap: 0.9rem; }
      .insight-item { border: 1px solid #dbeafe; background: #eef2ff; border-radius: 12px; padding: 0.9rem 1rem; box-shadow: inset 0 1px 2px rgba(59,130,246,0.12); }
      .insight-item h4 { margin: 0 0 0.45rem; font-size: 1rem; color: #1d4ed8; }
      .insight-meta { font-size: 0.75rem; color: #4b5563; margin-bottom: 0.4rem; letter-spacing: 0.04em; text-transform: uppercase; }
      .insight-summary { font-size: 0.9rem; color: #1f2937; margin: 0 0 0.45rem; }
      .insight-keywords { font-size: 0.8rem; color: #2563eb; }
      .insight-actions { display: flex; gap: 0.5rem; margin-top: 0.6rem; }
      .insight-action { padding: 0.35rem 0.8rem; border-radius: 999px; border: 1px solid #d1d5db; background: #fff; font-size: 0.8rem; cursor: pointer; transition: background 0.2s ease, color 0.2s ease; }
      .insight-action:hover { background: #eff6ff; color: #1d4ed8; }
      .insight-action.destructive { border-color: #fca5a5; color: #b91c1c; }
      .insight-action.destructive:hover { background: #fee2e2; color: #b91c1c; }
      .ai-insight-list { display: grid; gap: 0.75rem; margin-top: 0.6rem; }
      .ai-insight { border: 1px solid #e5e7eb; background: #fefefe; border-radius: 12px; padding: 0.8rem 1rem; box-shadow: inset 0 1px 2px rgba(15,23,42,0.06); }
      .ai-insight h4 { margin: 0 0 0.35rem; font-size: 1rem; color: #111827; }
      .ai-insight-summary { margin: 0; font-size: 0.95rem; color: #1f2937; }
      .ai-insight-meta { font-size: 0.8rem; color: #4b5563; margin-top: 0.35rem; }
      @media (max-width: 960px) {
        main { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <nav>
      <a href="/">Search</a>
      <a href="/support">Support Agent</a>
      <a href="/knowledge">Knowledge Base</a>
      <a href="/keywords"><strong>Keyword Explorer</strong></a>
      <a href="/admin/analytics">Analytics</a>
      <a href="/personas">Personas</a>
    </nav>
    <main>
      <aside>
        <h1>Keyword Explorer</h1>
        <p>Pick a project, run a keyword scan, and inspect core concepts pulled from its knowledge base.</p>
        <div class="form-grid">
          <label for="project">Project</label>
          <select id="project" aria-label="Select project">
            {% for project in projects %}
              <option value="{{ project.id }}" {% if project.id == selected_project %}selected{% endif %}>{{ project.name }}</option>
            {% endfor %}
          </select>
          <button id="keyword-search" class="primary" type="button">Run Keyword Scan</button>
          <div id="keyword-progress" class="progress-track"><div class="progress-indicator"></div></div>
          <p id="keyword-status" class="status-line">Select a project and click Run Keyword Scan to generate keyword candidates.</p>
        </div>
        <div id="keyword-list" class="keyword-list" aria-live="polite"></div>
        <div id="keyword-pagination" class="keyword-pagination" aria-live="polite">
          <button id="keyword-prev" type="button">Previous</button>
          <span id="keyword-page-label"></span>
          <button id="keyword-next" type="button">Next</button>
        </div>
      </aside>
      <section>
        <div class="detail-header">
          <h2 id="detail-title">Keyword details</h2>
          <div class="detail-actions">
            <span id="detail-subtitle" class="status-line"></span>
            <button id="save-insight" class="save-button" type="button" disabled>Save insight</button>
            <span id="save-status" class="save-status"></span>
          </div>
        </div>
        <div class="detail-columns">
          <div class="detail-card" id="candidate-card">
            <h3>Candidate snippets</h3>
            <div id="candidate-list" aria-live="polite"></div>
          </div>
          <div class="detail-card" id="definition-card">
            <h3>Definitions</h3>
            <div id="definition-list" aria-live="polite"></div>
          </div>
          <div class="detail-card" id="stage7-card">
            <h3>LLM insights</h3>
            <p id="stage7-status" class="status-line">Search to generate summarised insights.</p>
            <div id="stage7-insight-list" class="ai-insight-list">
              <p class="status-line">No insights yet.</p>
            </div>
          </div>
          <div class="detail-card" id="insights-card">
            <h3>Saved insights</h3>
            <div id="insight-list">
              <p class="status-line">No insights saved yet.</p>
            </div>
          </div>
        </div>
      </section>
    </main>
    <script>
      const keywordRunAsyncEnabled = {{ (settings.keyword_run_async_enabled if settings is defined else false) | tojson }};

      document.addEventListener('DOMContentLoaded', () => {
        const projectSelect = document.getElementById('project');
        const keywordList = document.getElementById('keyword-list');
        const paginationContainer = document.getElementById('keyword-pagination');
        const prevButton = document.getElementById('keyword-prev');
        const nextButton = document.getElementById('keyword-next');
        const paginationLabel = document.getElementById('keyword-page-label');
        const keywordProgress = document.getElementById('keyword-progress');
        const keywordStatus = document.getElementById('keyword-status');
        const searchButton = document.getElementById('keyword-search');
        const detailTitle = document.getElementById('detail-title');
        const detailSubtitle = document.getElementById('detail-subtitle');
        const saveButton = document.getElementById('save-insight');
        const saveStatus = document.getElementById('save-status');
        const candidateList = document.getElementById('candidate-list');
        const definitionList = document.getElementById('definition-list');
        const insightList = document.getElementById('insight-list');
        const stage7Status = document.getElementById('stage7-status');
        const stage7List = document.getElementById('stage7-insight-list');

        const DEFAULT_PAGE_SIZE = 50;

        let keywords = [];
        let selectedTerm = null;
        let currentInsight = null;
        let currentFilter = {};
        let pageSize = DEFAULT_PAGE_SIZE;
        let savedInsights = [];
        let stage7Insights = [];
        let stage7Job = null;
        let stage7TimerId = null;
        let activeRunJobId = null;
        let runPollTimerId = null;
        let latestRunStatus = null;

        function emptyPaginationState() {
          return {
            page: 1,
            page_size: pageSize,
            total: 0,
            pages: 0,
            has_next: false,
            has_prev: false,
            range_start: 0,
            range_end: 0,
          };
        }

        let pagination = emptyPaginationState();

        function resetPaginationControls() {
          paginationContainer.classList.remove('active');
          paginationLabel.textContent = '';
          prevButton.disabled = true;
          nextButton.disabled = true;
        }

        function clearKeywordList() {
          keywordList.innerHTML = '';
          resetPaginationControls();
        }

        function clearDetail() {
          candidateList.innerHTML = '<p class="status-line">Pick a keyword to see related snippets.</p>';
          definitionList.innerHTML = '<p class="status-line">Definitions will appear here when available.</p>';
          detailTitle.textContent = 'Keyword details';
          detailSubtitle.textContent = '';
        }

        function toNumber(value, fallback = 0) {
          const parsed = Number(value);
          return Number.isFinite(parsed) ? parsed : fallback;
        }

        function formatRangeDescription(info) {
          const total = toNumber(info.total, 0);
          if (!total) {
            return '';
          }
          const start = Math.min(toNumber(info.range_start, 1), total);
          const tentativeEnd = toNumber(info.range_end, start + Math.max(0, keywords.length) - 1);
          const end = Math.min(Math.max(start, tentativeEnd), total);
          const basePageSize = Math.max(1, toNumber(info.page_size, pageSize));
          const pages = Math.max(1, toNumber(info.pages, Math.ceil(total / basePageSize)));
          const pageNumber = Math.min(Math.max(1, toNumber(info.page, 1)), pages);
          return `Showing ${start}–${end} of ${total} keyword${total === 1 ? '' : 's'} (page ${pageNumber} of ${pages}).`;
        }

        function cancelStage7Polling() {
          if (stage7TimerId) {
            window.clearTimeout(stage7TimerId);
            stage7TimerId = null;
          }
        }

        function setStage7Status(message, color = '#4b5563') {
          if (!stage7Status) {
            return;
          }
          stage7Status.textContent = message;
          stage7Status.style.color = color;
        }

        function renderStage7Insights() {
          if (!stage7List) {
            return;
          }
          if (!stage7Insights.length) {
            stage7List.innerHTML = '<p class="status-line">No insights yet.</p>';
            return;
          }
          const fragment = document.createDocumentFragment();
          stage7Insights.forEach((item) => {
            const card = document.createElement('article');
            card.className = 'ai-insight';

            const title = document.createElement('h4');
            title.textContent = item.title || 'Insight';
            card.appendChild(title);

            if (item.summary) {
              const summary = document.createElement('p');
              summary.className = 'ai-insight-summary';
              summary.textContent = item.summary;
              card.appendChild(summary);
            }

            if (Array.isArray(item.keywords) && item.keywords.length) {
              const keywordsLine = document.createElement('div');
              keywordsLine.className = 'ai-insight-meta';
              keywordsLine.textContent = `Keywords: ${item.keywords.slice(0, 5).join(', ')}`;
              card.appendChild(keywordsLine);
            }

            if (item.action) {
              const actionLine = document.createElement('div');
              actionLine.className = 'ai-insight-meta';
              actionLine.textContent = `Action: ${item.action}`;
              card.appendChild(actionLine);
            }

            if (Array.isArray(item.evidence) && item.evidence.length) {
              const evidenceLine = document.createElement('div');
              evidenceLine.className = 'ai-insight-meta';
              evidenceLine.textContent = `Evidence: ${item.evidence.slice(0, 2).join(' • ')}`;
              card.appendChild(evidenceLine);
            }

            if (item.priority) {
              const priorityLine = document.createElement('div');
              priorityLine.className = 'ai-insight-meta';
              priorityLine.textContent = `Priority: ${item.priority}`;
              card.appendChild(priorityLine);
            }

            fragment.appendChild(card);
          });
          stage7List.innerHTML = '';
          stage7List.appendChild(fragment);
        }

        function resetStage7Card(options = {}) {
          cancelStage7Polling();
          stage7Insights = [];
          stage7Job = null;
          renderStage7Insights();
          if (options.initial) {
            setStage7Status('Select a project and run a keyword scan to generate summarised insights.', '#6b7280');
          } else if (options.preparing) {
            setStage7Status('Preparing summarised insights…', '#1f2937');
          } else {
            setStage7Status('No insights yet.', '#6b7280');
          }
        }

        function scheduleStage7Poll(jobId, delayMs) {
          const delay = Math.max(500, toNumber(delayMs, 1500));
          cancelStage7Polling();
          stage7TimerId = window.setTimeout(() => {
            pollStage7Job(jobId).catch((error) => console.error(error));
          }, delay);
        }

        async function pollStage7Job(jobId) {
          const projectId = projectSelect.value;
          if (!projectId || !jobId) {
            cancelStage7Polling();
            return;
          }
          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/insight-jobs/${encodeURIComponent(jobId)}`);
            if (response.status === 404) {
              cancelStage7Polling();
              setStage7Status('Insight summary job was not found.', '#b91c1c');
              return;
            }
            if (!response.ok) {
              throw new Error(`Failed to fetch insight job status (${response.status})`);
            }
            const payload = await response.json();
            if (payload.projectId && payload.projectId !== projectId) {
              cancelStage7Polling();
              return;
            }
            stage7Job = payload;
            if (Array.isArray(payload.insights)) {
              stage7Insights = payload.insights;
            }
            renderStage7Insights();
            const meta = {};
            updateStage7Status(meta, payload);
          } catch (error) {
            console.error(error);
            scheduleStage7Poll(jobId, 3000);
            setStage7Status('Retrying insight summary…', '#b45309');
          }
        }

        function updateStage7Status(meta, job) {
          const reason = meta && meta.reason ? meta.reason : '';
          if (job) {
            stage7Job = job;
            if (job.status === 'success') {
              cancelStage7Polling();
              if (stage7Insights.length) {
                setStage7Status(`Generated ${stage7Insights.length} insight${stage7Insights.length === 1 ? '' : 's'}.`, '#047857');
              } else {
                setStage7Status('No insights were generated for this run.', '#6b7280');
              }
              return;
            }
            if (job.status === 'error') {
              cancelStage7Polling();
              const suffix = job.error ? `: ${job.error}` : '';
              setStage7Status(`Insight generation failed${suffix}.`, '#b91c1c');
              if (stage7List) {
                stage7List.innerHTML = '<p class="status-line">Insight generation failed.</p>';
              }
              return;
            }
            if (!job.id) {
              cancelStage7Polling();
              setStage7Status('Insight job is missing an identifier.', '#b91c1c');
              return;
            }
            const delay = toNumber(job.poll_after ?? (meta && meta.poll_after), 1500);
            setStage7Status('Generating summarised insights…', '#1d4ed8');
            scheduleStage7Poll(job.id, delay);
            return;
          }

          cancelStage7Polling();
          stage7Job = null;
          if (reason === 'skipped') {
            const limit = meta && meta.limit ? ` (limit ${meta.limit})` : '';
            setStage7Status(`Insight summarisation skipped${limit}.`, '#b45309');
            return;
          }
          if (reason === 'disabled') {
            setStage7Status('Insight summarisation disabled for this configuration.', '#6b7280');
            return;
          }
          if (reason === 'error') {
            const suffix = meta && meta.error ? `: ${meta.error}` : '';
            setStage7Status(`Insight summarisation failed${suffix}.`, '#b91c1c');
            if (stage7List) {
              stage7List.innerHTML = '<p class="status-line">Insight generation failed.</p>';
            }
            return;
          }
          if (stage7Insights.length) {
            setStage7Status(`Generated ${stage7Insights.length} insight${stage7Insights.length === 1 ? '' : 's'}.`, '#047857');
          } else {
            setStage7Status('No insights were generated for this run.', '#6b7280');
          }
        }

        function handleStage7Response(data) {
          const stage7Meta = data && data.filter && data.filter.stage7 ? data.filter.stage7 : {};
          stage7Insights = Array.isArray(data.insights) ? data.insights : [];
          renderStage7Insights();
          let job = data.insightJob || null;
          if (job && stage7Meta && stage7Meta.poll_after && !job.poll_after) {
            job.poll_after = stage7Meta.poll_after;
          }
          updateStage7Status(stage7Meta, job);
        }

        function setProgressActive(isActive) {
          if (!keywordProgress) {
            return;
          }
          keywordProgress.classList.toggle('active', Boolean(isActive));
        }        function cancelRunPolling() {
          if (runPollTimerId) {
            window.clearTimeout(runPollTimerId);
            runPollTimerId = null;
          }
        }

        function scheduleRunPoll(jobId, delayMs) {
          const delay = Math.max(750, toNumber(delayMs, 2000));
          cancelRunPolling();
          runPollTimerId = window.setTimeout(() => {
            pollKeywordRun(jobId).catch((error) => console.error(error));
          }, delay);
        }

        async function pollKeywordRun(jobId) {
          const projectId = projectSelect.value;
          if (!projectId || !jobId) {
            cancelRunPolling();
            return;
          }
          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/runs/${encodeURIComponent(jobId)}`);
            if (response.status === 404) {
              cancelRunPolling();
              keywordStatus.dataset.status = 'error';
              keywordStatus.style.color = '#b91c1c';
              keywordStatus.textContent = 'Keyword run was not found. Try starting a new scan.';
              return;
            }
            if (!response.ok) {
              throw new Error(`Failed to fetch keyword run status (${response.status})`);
            }
            const payload = await response.json();
            const status = payload.status || '';
            const runInfo = payload.run || {};
            activeRunJobId = jobId;
            if (status === 'success') {
              cancelRunPolling();
              keywordStatus.dataset.status = 'success';
              keywordStatus.style.color = '#047857';
              keywordStatus.textContent = 'Keyword run completed. Refreshing…';
              await loadKeywords(1);
              return;
            }
            if (status === 'error') {
              cancelRunPolling();
              keywordStatus.dataset.status = 'error';
              keywordStatus.style.color = '#b91c1c';
              const message = runInfo.error ? `Keyword run failed: ${runInfo.error}` : 'Keyword run failed.';
              keywordStatus.textContent = message;
              return;
            }
            keywordStatus.dataset.status = status || 'running';
            keywordStatus.style.color = '#1d4ed8';
            const stats = runInfo.stats || {};
            let statusText = status === 'running' ? 'Keyword run in progress…' : 'Keyword run queued…';
            if (status === 'running' && stats.batch_total && stats.batch_total > 0) {
              const totalBatches = toNumber(stats.batch_total, 0);
              const completedBatches = Math.min(
                totalBatches,
                Math.max(0, toNumber(stats.batches_completed, 0)),
              );
              const totalCandidates = toNumber(
                stats.candidate_total ?? stats.stage2_candidate_total,
                0,
              );
              const processedCandidates = Math.min(
                totalCandidates || Number.POSITIVE_INFINITY,
                Math.max(0, toNumber(stats.candidates_processed, 0)),
              );
              let progressDetail = '';
              if (totalBatches > 0) {
                progressDetail = `batch ${completedBatches}/${totalBatches}`;
              }
              if (totalCandidates > 0) {
                progressDetail += progressDetail
                  ? ` • ${processedCandidates.toLocaleString()} of ${totalCandidates.toLocaleString()} candidates`
                  : `${processedCandidates.toLocaleString()} of ${totalCandidates.toLocaleString()} candidates`;
              }
              statusText = progressDetail
                ? `Keyword run in progress – ${progressDetail}`
                : 'Keyword run in progress…';
            } else if (status === 'running' && stats.chunk_total) {
              statusText = `Keyword run in progress… (${stats.chunk_total} chunks processed)`;
            }
            keywordStatus.textContent = statusText;
            const delayMsRaw = runInfo.poll_after_ms ?? stats.poll_after_ms;
            const delaySecondsRaw = runInfo.poll_after ?? stats.poll_after;
            let delayMs = toNumber(delayMsRaw, NaN);
            if (!Number.isFinite(delayMs)) {
              const delaySeconds = toNumber(delaySecondsRaw, NaN);
              delayMs = Number.isFinite(delaySeconds) ? delaySeconds * 1000 : 2000;
            }
            scheduleRunPoll(jobId, delayMs);
          } catch (error) {
            console.error(error);
            keywordStatus.dataset.status = 'retrying';
            keywordStatus.style.color = '#b45309';
            keywordStatus.textContent = 'Retrying keyword run status…';
            scheduleRunPoll(jobId, 3000);
          }
        }

        async function startKeywordRun() {
          const projectId = projectSelect.value;
          if (!projectId) {
            keywordStatus.textContent = 'Select a project first.';
            keywordStatus.style.color = '#b91c1c';
            keywordStatus.dataset.status = 'error';
            return;
          }
          try {
            searchButton.disabled = true;
            cancelRunPolling();
            keywordStatus.dataset.status = 'queueing';
            keywordStatus.style.color = '#1d4ed8';
            keywordStatus.textContent = 'Submitting keyword run…';
            setProgressActive(true);
            resetStage7Card({ preparing: true });
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/runs`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
            });
            if (response.status === 503) {
              keywordStatus.dataset.status = 'error';
              keywordStatus.style.color = '#b91c1c';
              keywordStatus.textContent = 'Background keyword jobs are disabled on this deployment.';
              await loadKeywords(1);
              return;
            }
            if (response.status === 429) {
              keywordStatus.dataset.status = 'error';
              keywordStatus.style.color = '#b91c1c';
              keywordStatus.textContent = 'Keyword run queue is full. Please retry in a moment.';
              return;
            }
            if (!response.ok) {
              throw new Error(`Failed to enqueue keyword run (status ${response.status})`);
            }
            const payload = await response.json();
            const jobId = payload.jobId;
            activeRunJobId = jobId;
            keywordStatus.dataset.status = 'running';
            keywordStatus.style.color = '#1d4ed8';
            keywordStatus.textContent = 'Keyword run queued…';
            if (payload.latest) {
              latestRunStatus = payload.latest;
              await loadKeywords(1);
            }
            scheduleRunPoll(jobId, 1500);
          } catch (error) {
            console.error(error);
            keywordStatus.dataset.status = 'error';
            keywordStatus.style.color = '#b91c1c';
            keywordStatus.textContent = 'Unable to enqueue keyword run. Please try again later.';
          } finally {
            searchButton.disabled = false;
            setProgressActive(false);
          }
        }

        async function loadKeywords(page = 1) {
          const projectId = projectSelect.value;
          if (!projectId) {
            keywordStatus.textContent = 'Select a project first.';
            keywordStatus.style.color = '#b91c1c';
            keywordStatus.dataset.status = 'error';
            setProgressActive(false);
            resetStage7Card({ initial: true });
            return;
          }

          pagination = emptyPaginationState();
          if (!keywordRunAsyncEnabled) {
            searchButton.disabled = true;
          }
          keywordStatus.dataset.status = 'loading';
          keywordStatus.style.color = '#1f2937';
          keywordStatus.textContent = keywordRunAsyncEnabled
            ? 'Loading keywords from the latest run…'
            : 'Scanning project documents for keywords…';
          setProgressActive(true);
          clearKeywordList();
          clearDetail();
          selectedTerm = null;
          currentInsight = null;
          currentFilter = {};
          saveButton.disabled = true;
          saveStatus.textContent = '';
          resetStage7Card({ preparing: true });

          const params = new URLSearchParams({
            page: String(page),
            page_size: String(pageSize),
          });

          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/candidates?${params.toString()}`);
            if (keywordRunAsyncEnabled && (response.status === 409 || response.status === 404)) {
              keywordStatus.dataset.status = response.status === 404 ? 'missing' : 'pending';
              keywordStatus.style.color = '#1f2937';
              keywordStatus.textContent = 'No keyword run available yet. Click “Run Keyword Scan” to generate results.';
              resetStage7Card({ initial: true });
              return;
            }
            if (!response.ok) {
              throw new Error(`Failed to fetch keywords (status ${response.status})`);
            }
            const data = await response.json();
            handleStage7Response(data);
            const filterInfo = data.filter || {};
            const status = filterInfo.status || 'unknown';
            currentFilter = filterInfo;
            keywordStatus.dataset.status = status;
            keywordStatus.style.color = '#1f2937';

            keywords = data.keywords || [];

            const paginationInfo = data.pagination || {};
            const resolvedPageSize = Math.max(1, toNumber(paginationInfo.page_size, pageSize));
            pageSize = resolvedPageSize;
            const total = Math.max(0, toNumber(paginationInfo.total, keywords.length));
            const totalPages = total ? Math.max(1, toNumber(paginationInfo.pages, Math.ceil(total / resolvedPageSize))) : 0;
            const currentPage = total ? Math.min(Math.max(1, toNumber(paginationInfo.page, page)), totalPages) : 1;
            const rangeStart = total ? Math.min(Math.max(1, toNumber(paginationInfo.range_start, (currentPage - 1) * resolvedPageSize + 1)), total) : 0;
            const computedRangeEnd = total ? Math.min(total, Math.max(rangeStart, toNumber(paginationInfo.range_end, rangeStart + Math.max(0, keywords.length) - 1))) : 0;
            const hasPrev = total ? currentPage > 1 : false;
            const hasNext = total ? computedRangeEnd < total : false;

            pagination = {
              page: currentPage,
              page_size: resolvedPageSize,
              total,
              pages: totalPages,
              has_next: hasNext,
              has_prev: hasPrev,
              range_start: rangeStart,
              range_end: computedRangeEnd,
            };

            const candidateCount = toNumber(filterInfo.candidate_count, total);
            const retainedCount = toNumber(filterInfo.selected_total, total);
            const rangeSuffix = formatRangeDescription(pagination);
            const suffix = rangeSuffix ? ` ${rangeSuffix}` : '';
            if (status === 'filtered') {
              keywordStatus.textContent = `LLM filtered ${candidateCount} candidates to ${retainedCount}.${suffix}`;
            } else if (status === 'bypass') {
              const reason = filterInfo.reason ? ` (reason: ${filterInfo.reason})` : '';
              keywordStatus.textContent = `LLM filtering bypassed${reason}; showing frequency list (${total}).${suffix}`;
              keywordStatus.style.color = '#b45309';
            } else if (status === 'error') {
              const reason = filterInfo.reason ? ` (${filterInfo.reason})` : '';
              keywordStatus.textContent = `LLM filtering failed${reason}; showing frequency list (${total}).${suffix}`;
              keywordStatus.style.color = '#b91c1c';
            } else {
              keywordStatus.textContent = `Found ${total} keyword candidate${total === 1 ? '' : 's'}.${suffix}`;
            }

            if (!keywords.length) {
              keywordStatus.textContent = 'No keyword candidates detected. Try ingesting more content.';
              keywordStatus.style.color = '#b91c1c';
              renderPagination();
              return;
            }

            renderKeywordList();
            renderPagination();
          } catch (error) {
            console.error(error);
            keywordStatus.textContent = 'Unable to load keywords right now. Please try again later.';
            keywordStatus.style.color = '#b91c1c';
            keywordStatus.dataset.status = 'error';
            resetPaginationControls();
            cancelStage7Polling();
            setStage7Status('Unable to generate insights.', '#b91c1c');
            if (stage7List) {
              stage7List.innerHTML = '<p class="status-line">Insight generation failed.</p>';
            }
          } finally {
            if (!keywordRunAsyncEnabled) {
              searchButton.disabled = false;
            }
            setProgressActive(false);
          }
        }

        function renderKeywordList() {
          clearKeywordList();
          keywords.forEach((item) => {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'keyword-pill';
            if (item.core) {
              button.classList.add('core');
            }
            if (item.generated) {
              button.classList.add('generated');
            }
            if (item.term === selectedTerm) {
              button.classList.add('active');
            }
            button.innerHTML = `
              <span class="keyword-term">${item.term}</span>
              <span class="keyword-count">×${item.count}</span>
            `;
            if (item.reason) {
              button.title = item.reason;
            } else if (item.generated) {
              button.title = 'LLM generated keyword';
            } else if (item.source === 'candidate') {
              button.title = 'Frequency candidate retained by LLM';
            }
            button.addEventListener('click', () => selectKeyword(item.term, button));
            keywordList.appendChild(button);
          });
        }

        function renderPagination() {
          const total = pagination.total || 0;
          const inferredPages = total ? Math.max(1, Math.ceil(total / Math.max(1, pagination.page_size))) : 0;
          const pages = pagination.pages || inferredPages;
          if (!total || pages <= 1) {
            resetPaginationControls();
            return;
          }
          paginationContainer.classList.add('active');
          prevButton.disabled = !pagination.has_prev;
          nextButton.disabled = !pagination.has_next;
          const displayPages = pages || 1;
          paginationLabel.textContent = `Page ${pagination.page} of ${displayPages} · ${pagination.range_start}–${pagination.range_end} / ${pagination.total}`;
        }

        async function selectKeyword(term, button) {
          if (selectedTerm === term) {
            return;
          }
          selectedTerm = term;
          document.querySelectorAll('.keyword-pill').forEach((pill) => {
            pill.classList.toggle('active', pill === button);
          });
          detailTitle.textContent = `Keyword: ${term}`;
          detailSubtitle.textContent = 'Loading contextual matches...';
          candidateList.innerHTML = '';
          definitionList.innerHTML = '';
          saveStatus.textContent = '';
          saveButton.disabled = true;

          try {
            const projectId = projectSelect.value;
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/definition?term=${encodeURIComponent(term)}`);
            if (!response.ok) {
              throw new Error(`Definition lookup failed (status ${response.status})`);
            }
            const data = await response.json();
            const candidates = data.candidates || [];
            const definitions = data.definitions || [];

            renderCandidates(candidates);
            renderDefinitions(definitions);
            detailSubtitle.textContent = `${candidates.length} candidate snippet${candidates.length === 1 ? '' : 's'} • ${definitions.length} glossary definition${definitions.length === 1 ? '' : 's'}`;
            currentInsight = {
              term,
              candidates,
              definitions,
              filter: { ...currentFilter, status: keywordStatus.dataset.status },
            };
            const selectedKeywordMeta = keywords.find((item) => item.term === term);
            if (selectedKeywordMeta) {
              currentInsight.filter.termMeta = selectedKeywordMeta;
            }
            saveButton.disabled = false;
          } catch (error) {
            console.error(error);
            candidateList.innerHTML = '<p class="status-line">Unable to load candidate snippets.</p>';
            definitionList.innerHTML = '<p class="status-line">Unable to load definitions.</p>';
            detailSubtitle.textContent = 'Lookup failed.';
            currentInsight = null;
            saveButton.disabled = true;
          }
        }

        function renderCandidates(candidates) {
          if (!candidates.length) {
            candidateList.innerHTML = '<p class="status-line">No snippets were retrieved for this keyword.</p>';
            return;
          }
          candidateList.innerHTML = '';
          candidates.forEach((candidate) => {
            const wrapper = document.createElement('div');
            wrapper.className = 'candidate-item';

            const meta = document.createElement('div');
            meta.className = 'candidate-meta';
            const parts = [];
            if (candidate.source) {
              parts.push(candidate.source);
            }
            if (typeof candidate.chunk_index === 'number') {
              parts.push(`Chunk ${candidate.chunk_index + 1}`);
            }
            meta.textContent = parts.join(' • ') || 'Snippet';

            const excerpt = document.createElement('pre');
            excerpt.className = 'candidate-snippet';
            excerpt.textContent = candidate.excerpt || candidate.snippet || '';
            if (candidate.snippet && candidate.snippet !== excerpt.textContent) {
              excerpt.title = candidate.snippet;
            }

            wrapper.appendChild(meta);
            wrapper.appendChild(excerpt);
            candidateList.appendChild(wrapper);
          });
        }

        function renderDefinitions(definitions) {
          if (!definitions.length) {
            definitionList.innerHTML = '<p class="status-line">No glossary definitions matched this keyword.</p>';
            return;
          }
          definitionList.innerHTML = '';
          definitions.forEach((definition) => {
            const item = document.createElement('div');
            item.className = 'definition-item';
            item.textContent = definition;
            definitionList.appendChild(item);
          });
        }

        async function loadInsights() {
          const projectId = projectSelect.value;
          if (!projectId) {
            savedInsights = [];
            renderInsights();
            return;
          }
          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/insights`);
            if (!response.ok) {
              throw new Error(`Insight lookup failed (${response.status})`);
            }
            const data = await response.json();
            savedInsights = Array.isArray(data.insights) ? data.insights : [];
          } catch (error) {
            console.error(error);
            savedInsights = [];
          }
          renderInsights();
        }

        async function handleEditInsight(insight) {
          if (!insight || !insight.id) {
            return;
          }
          const projectId = projectSelect.value;
          if (!projectId) {
            return;
          }
          const currentTerm = insight.term || '';
          const nextTerm = window.prompt('Update insight title', currentTerm);
          if (nextTerm === null) {
            return;
          }
          const trimmed = nextTerm.trim();
          if (!trimmed || trimmed === currentTerm) {
            return;
          }
          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/insights/${encodeURIComponent(insight.id)}`, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ term: trimmed }),
            });
            if (!response.ok) {
              throw new Error(`Insight update failed (${response.status})`);
            }
            await loadInsights();
          } catch (error) {
            console.error(error);
            window.alert('Failed to update insight.');
          }
        }

        async function handleDeleteInsight(insight) {
          if (!insight || !insight.id) {
            return;
          }
          if (!window.confirm('Delete this insight permanently?')) {
            return;
          }
          const projectId = projectSelect.value;
          if (!projectId) {
            return;
          }
          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/insights/${encodeURIComponent(insight.id)}`, {
              method: 'DELETE',
            });
            if (response.status !== 204) {
              throw new Error(`Delete failed (${response.status})`);
            }
            await loadInsights();
          } catch (error) {
            console.error(error);
            window.alert('Failed to delete insight.');
          }
        }

        function renderInsights() {
          if (!insightList) {
            return;
          }
          if (!savedInsights.length) {
            insightList.innerHTML = '<p class="status-line">No insights saved yet.</p>';
            return;
          }
          const fragment = document.createDocumentFragment();
          savedInsights.slice(0, 6).forEach((insight) => {
            const container = document.createElement('article');
            container.className = 'insight-item';

            const meta = document.createElement('div');
            meta.className = 'insight-meta';
            const createdAt = insight.created_at ? new Date(insight.created_at).toLocaleString() : 'Unknown';
            meta.textContent = `${insight.term || 'Keyword insight'} · ${createdAt}`;

            const title = document.createElement('h4');
            title.textContent = insight.term || 'Keyword insight';

            const summary = document.createElement('p');
            summary.className = 'insight-summary';
            const candidateCount = Array.isArray(insight.candidates) ? insight.candidates.length : 0;
            const definitionCount = Array.isArray(insight.definitions) ? insight.definitions.length : 0;
            summary.textContent = `${candidateCount} snippet${candidateCount === 1 ? '' : 's'}, ${definitionCount} definition${definitionCount === 1 ? '' : 's'}`;

            const keywordsLine = document.createElement('div');
            keywordsLine.className = 'insight-keywords';
            const filterStatus = insight.filter && insight.filter.status ? insight.filter.status : 'n/a';
            keywordsLine.textContent = `Filter status: ${filterStatus}`;

            let actions = null;
            if (insight.id) {
              actions = document.createElement('div');
              actions.className = 'insight-actions';

              const editButton = document.createElement('button');
              editButton.type = 'button';
              editButton.className = 'insight-action';
              editButton.textContent = 'Edit';
              editButton.addEventListener('click', () => {
                handleEditInsight(insight).catch((error) => console.error(error));
              });

              const deleteButton = document.createElement('button');
              deleteButton.type = 'button';
              deleteButton.className = 'insight-action destructive';
              deleteButton.textContent = 'Delete';
              deleteButton.addEventListener('click', () => {
                handleDeleteInsight(insight).catch((error) => console.error(error));
              });

              actions.append(editButton, deleteButton);
            }

            container.append(meta, title, summary, keywordsLine);
            if (actions) {
              container.appendChild(actions);
            }
            fragment.appendChild(container);
          });
          insightList.innerHTML = '';
          insightList.appendChild(fragment);
        }

        searchButton.addEventListener('click', () => {
          if (keywordRunAsyncEnabled) {
            startKeywordRun().catch((error) => console.error(error));
          } else {
            loadKeywords(1);
          }
        });
        projectSelect.addEventListener('change', () => {
          cancelRunPolling();
          keywords = [];
          selectedTerm = null;
          pageSize = DEFAULT_PAGE_SIZE;
          pagination = emptyPaginationState();
          clearKeywordList();
          clearDetail();
          keywordStatus.style.color = '#1f2937';
          keywordStatus.dataset.status = '';
          keywordStatus.textContent = keywordRunAsyncEnabled
            ? 'Select “Run Keyword Scan” to refresh keywords or load the latest run.'
            : 'Select a project and click run to generate keyword candidates.';
          currentInsight = null;
          currentFilter = {};
          saveButton.disabled = true;
          saveStatus.textContent = '';
          savedInsights = [];
          renderInsights();
          resetStage7Card({ initial: true });
          if (keywordRunAsyncEnabled) {
            loadKeywords(1).catch((error) => console.error(error));
          }
          loadInsights().catch((error) => console.error(error));
        if (keywordRunAsyncEnabled) {
          loadKeywords(1).catch((error) => console.error(error));
        }
        });
        prevButton.addEventListener('click', () => {
          if (pagination.has_prev) {
            loadKeywords(Math.max(1, pagination.page - 1));
          }
        });
        nextButton.addEventListener('click', () => {
          if (pagination.has_next) {
            loadKeywords(pagination.page + 1);
          }
        });

        saveButton.addEventListener('click', async () => {
          if (!currentInsight) {
            return;
          }
          const projectId = projectSelect.value;
          saveButton.disabled = true;
          saveStatus.style.color = '#1f2937';
          saveStatus.textContent = 'Saving insight…';
          try {
            const response = await fetch(`/keywords/${encodeURIComponent(projectId)}/insights`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(currentInsight),
            });
            if (!response.ok) {
              throw new Error(`Save failed with status ${response.status}`);
            }
            const data = await response.json();
            saveStatus.style.color = '#047857';
            saveStatus.textContent = `Saved insight (${data.id.slice(0, 6)})`;
            await loadInsights();
          } catch (error) {
            console.error(error);
            saveStatus.style.color = '#b91c1c';
            saveStatus.textContent = 'Failed to save insight.';
          } finally {
            saveButton.disabled = false;
          }
        });

        resetPaginationControls();
        clearDetail();
        resetStage7Card({ initial: true });
        renderInsights();
        loadInsights().catch((error) => console.error(error));
        if (keywordRunAsyncEnabled) {
          loadKeywords(1).catch((error) => console.error(error));
        }
      });
    </script>
  </body>
</html>
